from django.utils import timezone
from django_ai_assistant import AIAssistant, method_tool
from datetime import datetime, timedelta
from decimal import Decimal
from .models import Category, Movement


class FinanceAIAssistant(AIAssistant):
    id = "finance_assistant"
    name = "Assistente de Finan√ßas"
    instructions = """Voc√™ √© um assistente inteligente especializado em gest√£o financeira.

    Voc√™ pode ajudar os usu√°rios a:
    - Registrar receitas e despesas
    - Listar movimenta√ß√µes financeiras
    - Verificar saldo por categoria
    - Criar e gerenciar categorias
    - Analisar gastos por per√≠odo

    Sempre seja √∫til, preciso e forne√ßa informa√ß√µes claras sobre as finan√ßas.
    Use as ferramentas dispon√≠veis para registrar e consultar movimenta√ß√µes financeiras.

    Quando listar movimenta√ß√µes, formate as informa√ß√µes de forma clara e leg√≠vel.
    Quando registrar movimenta√ß√µes, confirme os detalhes registrados.

    Para valores monet√°rios, sempre use o formato brasileiro (R$ 100,50).
    Ao registrar uma movimenta√ß√£o, n√£o √© necess√°rio pedir confirma√ß√£o, apenas registre.
    Analise e insira no categoria que fa√ßa mais sentido"""
    model = "gpt-4o-mini"

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._user = kwargs.get('user')

    def get_instructions(self):
        return f"{self.instructions}\n\nData e hora atual: {timezone.now().strftime('%d/%m/%Y %H:%M')}"

    @method_tool
    def listar_movimentacoes(self, limite: int = 10, tipo: str = "", categoria: str = "") -> str:
        """Lista as movimenta√ß√µes financeiras

        Args:
            limite: N√∫mero m√°ximo de movimenta√ß√µes para retornar (padr√£o: 10)
            tipo: Filtro por tipo ('income' para receitas, 'expense' para despesas, vazio para todos)
            categoria: Nome da categoria para filtrar (opcional)

        Returns:
            String com as movimenta√ß√µes formatadas ou mensagem de erro
        """
        try:
            user = self._user
            queryset = Movement.objects.filter(user=user)

            # Aplicar filtros
            if tipo in ['income', 'expense']:
                queryset = queryset.filter(type=tipo)

            if categoria:
                queryset = queryset.filter(category__name__icontains=categoria)

            movements = queryset.order_by('-date', '-created_at')[:limite]

            if not movements:
                return "üí∞ Voc√™ ainda n√£o tem movimenta√ß√µes registradas."

            movimentacoes_formatadas = ["üí∞ *Suas Movimenta√ß√µes:*\n"]

            total_receitas = sum(m.amount for m in movements if m.type == 'income')
            total_despesas = sum(m.amount for m in movements if m.type == 'expense')
            saldo = total_receitas - total_despesas

            for i, movement in enumerate(movements, 1):
                tipo_icon = "üìà" if movement.type == 'income' else "üìâ"
                sinal = "+" if movement.type == 'income' else "-"
                cor = "üü¢" if movement.type == 'income' else "üî¥"

                data_formatada = movement.date.strftime('%d/%m/%Y')

                movimento_info = f"{i}. {tipo_icon} *{movement.description}*\n"
                movimento_info += f"   {cor} {sinal}R$ {movement.amount:.2f}\n"
                movimento_info += f"   üìÖ {data_formatada}\n"
                movimento_info += f"   üè∑Ô∏è {movement.category.name}"

                movimentacoes_formatadas.append(movimento_info)

            resultado = "\n\n".join(movimentacoes_formatadas)

            # Adicionar resumo
            resultado += f"\n\nüìä *Resumo do per√≠odo:*\n"
            resultado += f"üìà Receitas: R$ {total_receitas:.2f}\n"
            resultado += f"üìâ Despesas: R$ {total_despesas:.2f}\n"
            resultado += f"üí∞ Saldo: R$ {saldo:.2f}"

            return resultado

        except Exception as e:
            return f"‚ùå Erro interno ao listar movimenta√ß√µes: {str(e)}"

    @method_tool
    def registrar_movimentacao(
        self,
        tipo: str,
        valor: float,
        descricao: str,
        categoria: str,
        data: str = ""
    ) -> str:
        """Registra uma nova movimenta√ß√£o financeira

        Args:
            tipo: Tipo da movimenta√ß√£o ('income' para receita, 'expense' para despesa)
            valor: Valor da movimenta√ß√£o (sempre positivo)
            descricao: Descri√ß√£o da movimenta√ß√£o
            categoria: Nome da categoria
            data: Data no formato DD/MM/YYYY (opcional, usa data atual se vazio)

        Returns:
            String com confirma√ß√£o de registro ou mensagem de erro
        """
        try:
            # Validar tipo
            if tipo not in ['income', 'expense']:
                return "‚ùå Tipo inv√°lido. Use 'income' para receita ou 'expense' para despesa."

            # Validar valor
            if valor <= 0:
                return "‚ùå O valor deve ser maior que zero."

            valor_decimal = Decimal(str(valor))

            # Processar data
            if data:
                try:
                    data_obj = datetime.strptime(data, '%d/%m/%Y').date()
                except ValueError:
                    return "‚ùå Formato de data inv√°lido. Use DD/MM/YYYY (ex: 25/12/2024)"
            else:
                data_obj = timezone.now().date()

            user = self._user

            # Buscar ou criar categoria
            category, created = Category.objects.get_or_create(
                user=user,
                name__iexact=categoria,
                defaults={'name': categoria, 'user': user}
            )

            if created:
                categoria_msg = f" (categoria '{categoria}' criada automaticamente)"
            else:
                categoria_msg = ""

            # Criar movimenta√ß√£o
            movement = Movement.objects.create(
                user=user,
                type=tipo,
                amount=valor_decimal,
                description=descricao,
                date=data_obj,
                category=category
            )

            # Formatar resposta
            tipo_display = "Receita" if tipo == 'income' else "Despesa"
            tipo_icon = "üìà" if tipo == 'income' else "üìâ"
            sinal = "+" if tipo == 'income' else "-"
            cor = "üü¢" if tipo == 'income' else "üî¥"

            resposta = f"""‚úÖ *{tipo_display} registrada com sucesso!*

{tipo_icon} *Descri√ß√£o:* {descricao}
{cor} *Valor:* {sinal}R$ {valor:.2f}
üìÖ *Data:* {data_obj.strftime('%d/%m/%Y')}
üè∑Ô∏è *Categoria:* {categoria}{categoria_msg}"""

            return resposta

        except Exception as e:
            return f"‚ùå Erro interno ao registrar movimenta√ß√£o: {str(e)}"

    @method_tool
    def saldo_por_categoria(self, periodo_dias: int = 30) -> str:
        """Mostra o saldo por categoria nos √∫ltimos dias

        Args:
            periodo_dias: N√∫mero de dias para considerar (padr√£o: 30)

        Returns:
            String com saldo por categoria formatado
        """
        try:
            user = self._user
            data_inicio = timezone.now().date() - timedelta(days=periodo_dias)

            movements = Movement.objects.filter(user=user, date__gte=data_inicio)

            if not movements:
                return f"üí∞ N√£o h√° movimenta√ß√µes nos √∫ltimos {periodo_dias} dias."

            # Agrupar por categoria
            categorias = {}
            for movement in movements:
                categoria_nome = movement.category.name
                if categoria_nome not in categorias:
                    categorias[categoria_nome] = {
                        'receitas': Decimal('0'),
                        'despesas': Decimal('0'),
                        'quantidade': 0
                    }

                if movement.type == 'income':
                    categorias[categoria_nome]['receitas'] += movement.amount
                else:
                    categorias[categoria_nome]['despesas'] += movement.amount

                categorias[categoria_nome]['quantidade'] += 1

            # Formatar resposta
            resultado = [f"üìä *Saldo por Categoria - √öltimos {periodo_dias} dias:*\n"]

            total_receitas = Decimal('0')
            total_despesas = Decimal('0')

            for categoria_nome, dados in sorted(categorias.items()):
                saldo_categoria = dados['receitas'] - dados['despesas']
                total_receitas += dados['receitas']
                total_despesas += dados['despesas']

                cor = "üü¢" if saldo_categoria >= 0 else "üî¥"
                sinal = "+" if saldo_categoria >= 0 else ""

                categoria_info = f"üè∑Ô∏è *{categoria_nome}*\n"
                categoria_info += f"   üìà Receitas: R$ {dados['receitas']:.2f}\n"
                categoria_info += f"   üìâ Despesas: R$ {dados['despesas']:.2f}\n"
                categoria_info += f"   {cor} Saldo: {sinal}R$ {saldo_categoria:.2f}\n"
                categoria_info += f"   üìä {dados['quantidade']} movimenta√ß√µes"

                resultado.append(categoria_info)

            # Totais
            saldo_total = total_receitas - total_despesas
            cor_total = "üü¢" if saldo_total >= 0 else "üî¥"
            sinal_total = "+" if saldo_total >= 0 else ""

            resultado.append(f"\nüí∞ *RESUMO GERAL:*")
            resultado.append(f"üìà Total Receitas: R$ {total_receitas:.2f}")
            resultado.append(f"üìâ Total Despesas: R$ {total_despesas:.2f}")
            resultado.append(f"{cor_total} *Saldo Final: {sinal_total}R$ {saldo_total:.2f}*")

            return "\n\n".join(resultado)

        except Exception as e:
            return f"‚ùå Erro interno ao calcular saldo por categoria: {str(e)}"

    @method_tool
    def listar_categorias(self) -> str:
        """Lista todas as categorias dispon√≠veis

        Returns:
            String com as categorias formatadas
        """
        try:
            user = self._user
            categories = Category.objects.filter(user=user, is_active=True).order_by('name')

            if not categories:
                return "üè∑Ô∏è Nenhuma categoria encontrada. As categorias s√£o criadas automaticamente quando voc√™ registra movimenta√ß√µes."

            resultado = ["üè∑Ô∏è *Categorias Dispon√≠veis:*\n"]

            for i, category in enumerate(categories, 1):
                # Contar movimenta√ß√µes da categoria
                total_movements = Movement.objects.filter(user=user, category=category).count()

                categoria_info = f"{i}. *{category.name}*"
                if category.description:
                    categoria_info += f"\n   üìù {category.description}"
                categoria_info += f"\n   üìä {total_movements} movimenta√ß√µes"

                resultado.append(categoria_info)

            return "\n\n".join(resultado)

        except Exception as e:
            return f"‚ùå Erro interno ao listar categorias: {str(e)}"

    @method_tool
    def criar_categoria(self, nome: str, descricao: str = "", cor: str = "#3498db") -> str:
        """Cria uma nova categoria

        Args:
            nome: Nome da categoria
            descricao: Descri√ß√£o da categoria (opcional)
            cor: Cor da categoria em hexadecimal (opcional, padr√£o: #3498db)

        Returns:
            String com confirma√ß√£o de cria√ß√£o ou mensagem de erro
        """
        try:
            user = self._user

            # Verificar se categoria j√° existe
            if Category.objects.filter(user=user, name__iexact=nome).exists():
                return f"‚ùå A categoria '{nome}' j√° existe."

            # Criar categoria
            category = Category.objects.create(
                user=user,
                name=nome,
                description=descricao,
                color=cor
            )

            resposta = f"""‚úÖ *Categoria criada com sucesso!*

üè∑Ô∏è *Nome:* {nome}"""

            if descricao:
                resposta += f"\nüìù *Descri√ß√£o:* {descricao}"

            resposta += f"\nüé® *Cor:* {cor}"

            return resposta

        except Exception as e:
            return f"‚ùå Erro interno ao criar categoria: {str(e)}"

    @method_tool
    def deletar_movimentacao(self, descricao: str = "", data: str = "", valor: float = 0) -> str:
        """Deleta uma movimenta√ß√£o financeira

        Args:
            descricao: Descri√ß√£o da movimenta√ß√£o (busca parcial)
            data: Data no formato DD/MM/YYYY (opcional)
            valor: Valor da movimenta√ß√£o (opcional)

        Returns:
            String com resultado da opera√ß√£o
        """
        try:
            user = self._user
            queryset = Movement.objects.filter(user=user)

            # Aplicar filtros
            if descricao:
                queryset = queryset.filter(description__icontains=descricao)

            if data:
                try:
                    data_obj = datetime.strptime(data, '%d/%m/%Y').date()
                    queryset = queryset.filter(date=data_obj)
                except ValueError:
                    return "‚ùå Formato de data inv√°lido. Use DD/MM/YYYY"

            if valor > 0:
                queryset = queryset.filter(amount=Decimal(str(valor)))

            movements = queryset.order_by('-date', '-created_at')

            if not movements:
                return "üòï N√£o encontrei nenhuma movimenta√ß√£o com esses crit√©rios."

            if movements.count() > 1:
                # Mostrar op√ß√µes se houver m√∫ltiplas movimenta√ß√µes
                resultado = ["‚ùì *Encontrei m√∫ltiplas movimenta√ß√µes:*\n"]
                for i, movement in enumerate(movements[:5], 1):
                    tipo_icon = "üìà" if movement.type == 'income' else "üìâ"
                    sinal = "+" if movement.type == 'income' else "-"

                    movimento_info = f"{i}. {tipo_icon} {movement.description}\n"
                    movimento_info += f"   {sinal}R$ {movement.amount:.2f} - {movement.date.strftime('%d/%m/%Y')}"

                    resultado.append(movimento_info)

                resultado.append("\nüí° *Seja mais espec√≠fico nos crit√©rios para deletar apenas uma movimenta√ß√£o.*")
                return "\n\n".join(resultado)

            # Deletar a movimenta√ß√£o encontrada
            movement = movements.first()
            tipo_display = "Receita" if movement.type == 'income' else "Despesa"
            descricao_movimento = movement.description
            valor_movimento = movement.amount
            data_movimento = movement.date.strftime('%d/%m/%Y')

            movement.delete()

            return f"üóëÔ∏è *{tipo_display} deletada com sucesso!*\n\nüìù {descricao_movimento}\nüí∞ R$ {valor_movimento:.2f}\nüìÖ {data_movimento}"

        except Exception as e:
            return f"‚ùå Erro interno ao deletar movimenta√ß√£o: {str(e)}"