from django.utils import timezone
from django.conf import settings
from django.db import models
from django_ai_assistant import AIAssistant, method_tool
from datetime import datetime, timedelta
from decimal import Decimal
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain_google_genai import ChatGoogleGenerativeAI
from .models import Category, Movement, PaymentMethod

"""Voc√™ √© um assistente inteligente especializado em gest√£o financeira.

    Voc√™ pode ajudar os usu√°rios a:
    - Registrar receitas e despesas
    - Listar movimenta√ß√µes financeiras
    - Verificar saldo por categoria
    - Criar e gerenciar categorias
    - Analisar gastos por per√≠odo
    - Gerenciar m√©todos de pagamento para despesas

    Sempre seja √∫til, preciso e forne√ßa informa√ß√µes claras sobre as finan√ßas.
    Use as ferramentas dispon√≠veis para registrar e consultar movimenta√ß√µes financeiras.

    IMPORTANTE: Quando usar qualquer ferramenta, retorne EXATAMENTE a resposta da ferramenta, sem adicionar, modificar ou reformular.
    As ferramentas j√° retornam mensagens formatadas e completas.

    Para valores monet√°rios, sempre use o formato brasileiro (R$ 100,50).
    Ao registrar uma movimenta√ß√£o, n√£o √© necess√°rio pedir confirma√ß√£o, apenas registre.
    Analise e insira na categoria que fa√ßa mais sentido.

    Para despesas, sempre especifique o m√©todo de pagamento (PIX, Dinheiro, Cart√£o, etc.).
    Se n√£o especificado, use "N√£o especificado" como padr√£o para despesas."""

class FinanceAIAssistant(AIAssistant):
    id = "finance_assistant"
    name = "Assistente de Finan√ßas"
    instructions = ""
    model = "gpt-4o-mini"

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._user = kwargs.get('user')
        self._llm_config = kwargs.get('llm_config')

        # Sobrescrever configura√ß√µes se llm_config for fornecido
        if self._llm_config:
            self.name = self._llm_config.display_name or "Assistente de Finan√ßas"
            self.model = self._llm_config.model
            if self._llm_config.instructions:
                self.instructions = self._llm_config.instructions

    def get_instructions(self):
        base_instructions = f"{self.instructions}\n\nData e hora atual: {timezone.now().strftime('%d/%m/%Y %H:%M')}"

        # Adicionar lista de categorias dispon√≠veis do usu√°rio
        if self._user:
            categories = Category.objects.filter(user=self._user, is_active=True).order_by('name')
            if categories.exists():
                categorias_lista = "\n".join([f"  - {cat.name}" for cat in categories])
                base_instructions += f"\n\n**CATEGORIAS DISPON√çVEIS DO USU√ÅRIO:**\n{categorias_lista}\n\nIMPORTANTE: Use EXATAMENTE um desses nomes de categoria ao registrar movimenta√ß√µes. Escolha a categoria que melhor se encaixa na descri√ß√£o da movimenta√ß√£o."

            # Adicionar lista de m√©todos de pagamento dispon√≠veis
            payment_methods = PaymentMethod.objects.filter(
                models.Q(user=self._user) | models.Q(user__isnull=True),
                is_active=True
            ).order_by('name')

            if payment_methods.exists():
                metodos_lista = "\n".join([f"  - {method.name}" for method in payment_methods])
                base_instructions += f"\n\n**M√âTODOS DE PAGAMENTO DISPON√çVEIS:**\n{metodos_lista}\n\nIMPORTANTE: Para despesas, sempre especifique o m√©todo de pagamento usando EXATAMENTE um desses nomes. Se n√£o especificado, use 'N√£o especificado' como padr√£o."

        return base_instructions

    def get_llm(self):
        if not self._llm_config:
            return super().get_llm()

        provider = self._llm_config.name

        if provider == "openai":
            return ChatOpenAI(
                model=self._llm_config.model,
                temperature=self._llm_config.temperature,
                max_tokens=self._llm_config.max_tokens,
                top_p=self._llm_config.top_p,
                presence_penalty=self._llm_config.presence_penalty,
                frequency_penalty=self._llm_config.frequency_penalty,
                openai_api_key=getattr(settings, 'OPENAI_API_KEY', '')
            )
        elif provider == "anthropic":
            return ChatAnthropic(
                model=self._llm_config.model,
                temperature=self._llm_config.temperature,
                max_tokens=self._llm_config.max_tokens,
                top_p=self._llm_config.top_p,
                anthropic_api_key=getattr(settings, 'ANTHROPIC_API_KEY', '')
            )
        elif provider == "google":
            return ChatGoogleGenerativeAI(
                model=self._llm_config.model,
                temperature=self._llm_config.temperature,
                max_output_tokens=self._llm_config.max_tokens,
                top_p=self._llm_config.top_p,
                google_api_key=getattr(settings, 'GOOGLE_API_KEY', '')
            )
        else:
            return ChatOpenAI(
                model=self._llm_config.model,
                temperature=self._llm_config.temperature,
                max_tokens=self._llm_config.max_tokens,
                openai_api_key=getattr(settings, 'OPENAI_API_KEY', '')
            )

    @method_tool
    def listar_movimentacoes(self, limite: int = 500, tipo: str = "", categoria: str = "", data_inicial: str = "", data_final: str = "") -> str:
        """Lista as movimenta√ß√µes financeiras

        Args:
            limite: N√∫mero m√°ximo de movimenta√ß√µes para retornar (padr√£o: 10)
            tipo: Filtro por tipo ('income' para receitas, 'expense' para despesas, vazio para todos)
            categoria: Nome da categoria para filtrar (opcional)
            data_inicial: Data inicial no formato DD/MM/YYYY (opcional)
            data_final: Data final no formato DD/MM/YYYY (opcional)

        Returns:
            String com as movimenta√ß√µes formatadas ou mensagem de erro
        """
        try:
            user = self._user
            queryset = Movement.objects.filter(user=user)

            # Aplicar filtros
            if tipo in ['income', 'expense']:
                queryset = queryset.filter(type=tipo)

            if categoria:
                queryset = queryset.filter(category__name__icontains=categoria)

            # Filtrar por per√≠odo (data do movimento, n√£o data de cria√ß√£o)
            print(f'data_inicial: {data_inicial}')
            if data_inicial:
                try:
                    data_inicio = datetime.strptime(data_inicial, '%d/%m/%Y').date()
                    queryset = queryset.filter(date__gte=data_inicio)
                except ValueError:
                    return "‚ùå Formato de data inicial inv√°lido. Use DD/MM/YYYY (ex: 25/12/2024)"

            print(f'data_final: {data_final}')
            if data_final:
                try:
                    data_fim = datetime.strptime(data_final, '%d/%m/%Y').date()
                    queryset = queryset.filter(date__lte=data_fim)
                except ValueError:
                    return "‚ùå Formato de data final inv√°lido. Use DD/MM/YYYY (ex: 25/12/2024)"

            movements = queryset.order_by('-date', '-created_at')[:limite]

            if not movements:
                return "üí∞ Voc√™ ainda n√£o tem movimenta√ß√µes registradas."

            movimentacoes_formatadas = ["üí∞ *Suas Movimenta√ß√µes:*\n"]

            total_receitas = sum(m.amount for m in movements if m.type == 'income')
            total_despesas = sum(m.amount for m in movements if m.type == 'expense')
            saldo = total_receitas - total_despesas

            for i, movement in enumerate(movements, 1):
                tipo_icon = "üìà" if movement.type == 'income' else "üìâ"
                sinal = "+" if movement.type == 'income' else "-"
                cor = "üü¢" if movement.type == 'income' else "üî¥"

                data_formatada = movement.date.strftime('%d/%m/%Y')

                movimento_info = f"{i}. {tipo_icon} *{movement.description}*\n"
                movimento_info += f"   {cor} {sinal}R$ {movement.amount:.2f}\n"
                movimento_info += f"   üìÖ {data_formatada}\n"
                movimento_info += f"   üè∑Ô∏è {movement.category.name}"

                # Adicionar m√©todo de pagamento se for despesa
                if movement.type == 'expense' and movement.payment_method:
                    movimento_info += f"\n   üí≥ {movement.payment_method.name}"

                movimentacoes_formatadas.append(movimento_info)

            resultado = "\n\n".join(movimentacoes_formatadas)

            # Adicionar resumo
            resultado += f"\n\nüìä *Resumo do per√≠odo:*\n"
            resultado += f"üìà Receitas: R$ {total_receitas:.2f}\n"
            resultado += f"üìâ Despesas: R$ {total_despesas:.2f}\n"
            resultado += f"üí∞ Saldo: R$ {saldo:.2f}"

            return resultado

        except Exception as e:
            return f"‚ùå Erro interno ao listar movimenta√ß√µes: {str(e)}"

    @method_tool
    def registrar_movimentacao(
        self,
        tipo: str,
        valor: float,
        descricao: str,
        categoria: str,
        data: str = "",
        metodo_pagamento: str = ""
    ) -> str:
        """Registra uma nova movimenta√ß√£o financeira

        Args:
            tipo: Tipo da movimenta√ß√£o ('income' para receita, 'expense' para despesa)
            valor: Valor da movimenta√ß√£o (sempre positivo)
            descricao: Descri√ß√£o da movimenta√ß√£o
            categoria: Nome da categoria
            data: Data no formato DD/MM/YYYY (opcional, usa data atual se vazio)
            metodo_pagamento: M√©todo de pagamento (obrigat√≥rio para despesas, opcional para receitas)

        Returns:
            String com confirma√ß√£o de registro ou mensagem de erro
        """
        try:
            # Validar tipo
            if tipo not in ['income', 'expense']:
                return "‚ùå Tipo inv√°lido. Use 'income' para receita ou 'expense' para despesa."

            # Validar valor
            if valor <= 0:
                return "‚ùå O valor deve ser maior que zero."

            valor_decimal = Decimal(str(valor))

            # Processar data
            if data:
                try:
                    data_obj = datetime.strptime(data, '%d/%m/%Y').date()
                except ValueError:
                    return "‚ùå Formato de data inv√°lido. Use DD/MM/YYYY (ex: 25/12/2024)"
            else:
                data_obj = timezone.now().date()

            user = self._user

            category = Category.objects.filter(user=user, name__iexact=categoria, is_active=True).first()

            if not category:
                available_categories = Category.objects.filter(user=user, is_active=True).values_list('name', flat=True)
                if not available_categories:
                    return "‚ùå Voc√™ ainda n√£o possui categorias cadastradas."

                categories_list = "\n".join([f"  - {cat}" for cat in available_categories])
                return f"‚ùå Categoria '{categoria}' n√£o encontrada. Use EXATAMENTE um dos nomes dispon√≠veis:\n\n{categories_list}"

            # Processar m√©todo de pagamento para despesas
            payment_method = None
            if tipo == 'expense':
                if not metodo_pagamento:
                    # Usar "N√£o especificado" como padr√£o se n√£o informado
                    metodo_pagamento = "N√£o especificado"

                payment_method = PaymentMethod.objects.filter(
                    models.Q(user=user) | models.Q(user__isnull=True),
                    name__iexact=metodo_pagamento,
                    is_active=True
                ).first()

                if not payment_method:
                    available_methods = PaymentMethod.objects.filter(
                        models.Q(user=user) | models.Q(user__isnull=True),
                        is_active=True
                    ).values_list('name', flat=True)

                    methods_list = "\n".join([f"  - {method}" for method in available_methods])
                    return f"‚ùå M√©todo de pagamento '{metodo_pagamento}' n√£o encontrado. Use EXATAMENTE um dos nomes dispon√≠veis:\n\n{methods_list}"

            Movement.objects.create(
                user=user,
                type=tipo,
                amount=valor_decimal,
                description=descricao,
                date=data_obj,
                category=category,
                payment_method=payment_method
            )

            tipo_display = "Receita" if tipo == 'income' else "Despesa"
            tipo_icon = "üìà" if tipo == 'income' else "üìâ"
            sinal = "+" if tipo == 'income' else "-"
            cor = "üü¢" if tipo == 'income' else "üî¥"

            resposta = f"""‚úÖ *{tipo_display} registrada com sucesso!*

{tipo_icon} *Descri√ß√£o:* {descricao}
{cor} *Valor:* {sinal}R$ {valor:.2f}
üìÖ *Data:* {data_obj.strftime('%d/%m/%Y')}
üè∑Ô∏è *Categoria:* {category.name}"""

            # Adicionar m√©todo de pagamento se for despesa
            if payment_method:
                resposta += f"\nüí≥ *M√©todo de Pagamento:* {payment_method.name}"

            return resposta

        except Exception as e:
            return f"‚ùå Erro interno ao registrar movimenta√ß√£o: {str(e)}"

    @method_tool
    def saldo_por_categoria(self, periodo_dias: int = 30) -> str:
        """Mostra o saldo por categoria nos √∫ltimos dias

        Args:
            periodo_dias: N√∫mero de dias para considerar (padr√£o: 30)

        Returns:
            String com saldo por categoria formatado
        """
        try:
            user = self._user
            data_inicio = timezone.now().date() - timedelta(days=periodo_dias)

            movements = Movement.objects.filter(user=user, date__gte=data_inicio)

            if not movements:
                return f"üí∞ N√£o h√° movimenta√ß√µes nos √∫ltimos {periodo_dias} dias."

            # Agrupar por categoria
            categorias = {}
            for movement in movements:
                categoria_nome = movement.category.name
                if categoria_nome not in categorias:
                    categorias[categoria_nome] = {
                        'receitas': Decimal('0'),
                        'despesas': Decimal('0'),
                        'quantidade': 0
                    }

                if movement.type == 'income':
                    categorias[categoria_nome]['receitas'] += movement.amount
                else:
                    categorias[categoria_nome]['despesas'] += movement.amount

                categorias[categoria_nome]['quantidade'] += 1

            # Formatar resposta
            resultado = [f"üìä *Saldo por Categoria - √öltimos {periodo_dias} dias:*\n"]

            total_receitas = Decimal('0')
            total_despesas = Decimal('0')

            for categoria_nome, dados in sorted(categorias.items()):
                saldo_categoria = dados['receitas'] - dados['despesas']
                total_receitas += dados['receitas']
                total_despesas += dados['despesas']

                cor = "üü¢" if saldo_categoria >= 0 else "üî¥"
                sinal = "+" if saldo_categoria >= 0 else ""

                categoria_info = f"üè∑Ô∏è *{categoria_nome}*\n"
                categoria_info += f"   üìà Receitas: R$ {dados['receitas']:.2f}\n"
                categoria_info += f"   üìâ Despesas: R$ {dados['despesas']:.2f}\n"
                categoria_info += f"   {cor} Saldo: {sinal}R$ {saldo_categoria:.2f}\n"
                categoria_info += f"   üìä {dados['quantidade']} movimenta√ß√µes"

                resultado.append(categoria_info)

            # Totais
            saldo_total = total_receitas - total_despesas
            cor_total = "üü¢" if saldo_total >= 0 else "üî¥"
            sinal_total = "+" if saldo_total >= 0 else ""

            resultado.append(f"\nüí∞ *RESUMO GERAL:*")
            resultado.append(f"üìà Total Receitas: R$ {total_receitas:.2f}")
            resultado.append(f"üìâ Total Despesas: R$ {total_despesas:.2f}")
            resultado.append(f"{cor_total} *Saldo Final: {sinal_total}R$ {saldo_total:.2f}*")

            return "\n\n".join(resultado)

        except Exception as e:
            return f"‚ùå Erro interno ao calcular saldo por categoria: {str(e)}"

    @method_tool
    def listar_categorias(self) -> str:
        """Lista todas as categorias dispon√≠veis

        Returns:
            String com as categorias formatadas
        """
        try:
            user = self._user
            categories = Category.objects.filter(user=user, is_active=True).order_by('name')

            if not categories:
                return "üè∑Ô∏è Nenhuma categoria encontrada. As categorias s√£o criadas automaticamente quando voc√™ registra movimenta√ß√µes."

            resultado = ["üè∑Ô∏è *Categorias Dispon√≠veis:*\n"]

            for i, category in enumerate(categories, 1):
                # Contar movimenta√ß√µes da categoria
                total_movements = Movement.objects.filter(user=user, category=category).count()

                categoria_info = f"{i}. *{category.name}*"
                if category.description:
                    categoria_info += f"\n   üìù {category.description}"
                categoria_info += f"\n   üìä {total_movements} movimenta√ß√µes"

                resultado.append(categoria_info)

            return "\n\n".join(resultado)

        except Exception as e:
            return f"‚ùå Erro interno ao listar categorias: {str(e)}"

    @method_tool
    def criar_categoria(self, nome: str, descricao: str = "", cor: str = "#3498db") -> str:
        """Cria uma nova categoria

        Args:
            nome: Nome da categoria
            descricao: Descri√ß√£o da categoria (opcional)
            cor: Cor da categoria em hexadecimal (opcional, padr√£o: #3498db)

        Returns:
            String com confirma√ß√£o de cria√ß√£o ou mensagem de erro
        """
        try:
            user = self._user

            # Verificar se categoria j√° existe
            if Category.objects.filter(user=user, name__iexact=nome).exists():
                return f"‚ùå A categoria '{nome}' j√° existe."

            # Criar categoria
            category = Category.objects.create(
                user=user,
                name=nome,
                description=descricao,
                color=cor
            )

            resposta = f"""‚úÖ *Categoria criada com sucesso!*

üè∑Ô∏è *Nome:* {nome}"""

            if descricao:
                resposta += f"\nüìù *Descri√ß√£o:* {descricao}"

            resposta += f"\nüé® *Cor:* {cor}"

            return resposta

        except Exception as e:
            return f"‚ùå Erro interno ao criar categoria: {str(e)}"

    @method_tool
    def deletar_categoria(self, nome: str) -> str:
        """Deleta uma categoria existente

        Args:
            nome: Nome da categoria a ser deletada

        Returns:
            String com resultado da opera√ß√£o
        """
        try:
            user = self._user

            # Buscar categoria
            category = Category.objects.filter(user=user, name__icontains=nome).first()

            if not category:
                return f"‚ùå Categoria '{nome}' n√£o encontrada."

            # Verificar se h√° movimenta√ß√µes usando esta categoria
            movements_count = Movement.objects.filter(user=user, category=category).count()

            if movements_count > 0:
                return f"‚ùå N√£o √© poss√≠vel deletar a categoria '{category.name}' pois ela possui {movements_count} movimenta√ß√µes associadas.\n\nüí° Voc√™ pode desativar a categoria ao inv√©s de delet√°-la."

            # Deletar categoria
            category_name = category.name
            category.delete()

            return f"üóëÔ∏è *Categoria deletada com sucesso!*\n\nüè∑Ô∏è {category_name}"

        except Exception as e:
            return f"‚ùå Erro interno ao deletar categoria: {str(e)}"

    @method_tool
    def deletar_movimentacao(self, descricao: str = "", data: str = "", valor: float = 0) -> str:
        """Deleta uma movimenta√ß√£o financeira

        Args:
            descricao: Descri√ß√£o da movimenta√ß√£o (busca parcial)
            data: Data no formato DD/MM/YYYY (opcional)
            valor: Valor da movimenta√ß√£o (opcional)

        Returns:
            String com resultado da opera√ß√£o
        """
        try:
            user = self._user
            queryset = Movement.objects.filter(user=user)

            # Aplicar filtros
            if descricao:
                queryset = queryset.filter(description__icontains=descricao)

            if data:
                try:
                    data_obj = datetime.strptime(data, '%d/%m/%Y').date()
                    queryset = queryset.filter(date=data_obj)
                except ValueError:
                    return "‚ùå Formato de data inv√°lido. Use DD/MM/YYYY"

            if valor > 0:
                queryset = queryset.filter(amount=Decimal(str(valor)))

            movements = queryset.order_by('-date', '-created_at')

            if not movements:
                return "üòï N√£o encontrei nenhuma movimenta√ß√£o com esses crit√©rios."

            if movements.count() > 1:
                # Mostrar op√ß√µes se houver m√∫ltiplas movimenta√ß√µes
                resultado = ["‚ùì *Encontrei m√∫ltiplas movimenta√ß√µes:*\n"]
                for i, movement in enumerate(movements[:5], 1):
                    tipo_icon = "üìà" if movement.type == 'income' else "üìâ"
                    sinal = "+" if movement.type == 'income' else "-"

                    movimento_info = f"{i}. {tipo_icon} {movement.description}\n"
                    movimento_info += f"   {sinal}R$ {movement.amount:.2f} - {movement.date.strftime('%d/%m/%Y')}"

                    resultado.append(movimento_info)

                resultado.append("\nüí° *Seja mais espec√≠fico nos crit√©rios para deletar apenas uma movimenta√ß√£o.*")
                return "\n\n".join(resultado)

            # Deletar a movimenta√ß√£o encontrada
            movement = movements.first()
            tipo_display = "Receita" if movement.type == 'income' else "Despesa"
            descricao_movimento = movement.description
            valor_movimento = movement.amount
            data_movimento = movement.date.strftime('%d/%m/%Y')

            movement.delete()

            return f"üóëÔ∏è *{tipo_display} deletada com sucesso!*\n\nüìù {descricao_movimento}\nüí∞ R$ {valor_movimento:.2f}\nüìÖ {data_movimento}"

        except Exception as e:
            return f"‚ùå Erro interno ao deletar movimenta√ß√£o: {str(e)}"